"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const rest_controller_1 = require("./rest-controller");
class AuthController extends rest_controller_1.default {
    constructor(prefix = '', config = {}) {
        super(prefix, config);
        this.authFilters = [];
        this.ignoreMethods = [];
        this.runAuthFilter = this.runAuthFilter.bind(this);
    }
    listWrapper(req, res, next) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            if (this.ignoreMethods.includes('list')) {
                return _super("listWrapper").call(this, req, res, next);
            }
            try {
                yield this.runAuthFilter(req, res);
            }
            catch (e) {
                return next(e);
            }
            _super("listWrapper").call(this, req, res, next);
        });
    }
    retrieveWrapper(req, res, next) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            if (this.ignoreMethods.includes('retrieve')) {
                return _super("retrieveWrapper").call(this, req, res, next);
            }
            try {
                yield this.runAuthFilter(req, res);
            }
            catch (e) {
                return next(e);
            }
            _super("retrieveWrapper").call(this, req, res, next);
        });
    }
    createWrapper(req, res, next) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            if (this.ignoreMethods.includes('create')) {
                return _super("createWrapper").call(this, req, res, next);
            }
            try {
                yield this.runAuthFilter(req, res);
            }
            catch (e) {
                return next(e);
            }
            _super("createWrapper").call(this, req, res, next);
        });
    }
    updateWrapper(req, res, next) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            if (this.ignoreMethods.includes('update')) {
                return _super("updateWrapper").call(this, req, res, next);
            }
            try {
                yield this.runAuthFilter(req, res);
            }
            catch (e) {
                return next(e);
            }
            _super("updateWrapper").call(this, req, res, next);
        });
    }
    destroyWrapper(req, res, next) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            if (this.ignoreMethods.includes('destroy')) {
                return _super("destroyWrapper").call(this, req, res, next);
            }
            try {
                yield this.runAuthFilter(req, res);
            }
            catch (e) {
                return next(e);
            }
            _super("destroyWrapper").call(this, req, res, next);
        });
    }
    runAuthFilter(req, res) {
        return new Promise((rsv, rr) => {
            Promise.all(this.mapAuthFilters(req, res))
                .then((results) => rsv())
                .catch(err => rr(err));
        });
    }
    mapAuthFilters(req, res) {
        return this.authFilters
            .map((f) => f && f.canAccess ? f.canAccess(req, res) : null)
            .filter(f => f != null);
    }
}
exports.default = AuthController;
